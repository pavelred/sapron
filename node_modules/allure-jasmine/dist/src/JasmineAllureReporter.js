"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const allure_js_commons_1 = require("allure-js-commons");
var SpecStatus;
(function (SpecStatus) {
    SpecStatus["PASSED"] = "passed";
    SpecStatus["FAILED"] = "failed";
    SpecStatus["BROKEN"] = "broken";
    SpecStatus["PENDING"] = "pending";
    SpecStatus["DISABLED"] = "disabled";
    SpecStatus["EXCLUDED"] = "excluded";
})(SpecStatus || (SpecStatus = {}));
class JasmineAllureReporter {
    constructor(config) {
        this.groupStack = [];
        this.labelStack = [[]];
        this.runningTest = null;
        this.stepStack = [];
        this.runningExecutable = null;
        this.runtime = new allure_js_commons_1.AllureRuntime(config);
        this.installHooks();
    }
    getCurrentGroup() {
        if (this.groupStack.length === 0)
            return null;
        return this.groupStack[this.groupStack.length - 1];
    }
    get currentGroup() {
        const currentGroup = this.getCurrentGroup();
        if (currentGroup === null)
            throw new Error("No active group");
        return currentGroup;
    }
    getInterface() {
        return new JasmineAllureInterface(this, this.runtime);
    }
    get currentTest() {
        if (this.runningTest === null)
            throw new Error("No active test");
        return this.runningTest;
    }
    get currentExecutable() {
        return this.runningExecutable;
    }
    writeAttachment(content, type) {
        return this.runtime.writeAttachment(content, type);
    }
    jasmineStarted(suiteInfo) {
    }
    suiteStarted(suite) {
        const name = suite.description;
        const group = (this.getCurrentGroup() || this.runtime).startGroup(name);
        this.groupStack.push(group);
        this.labelStack.push([]);
    }
    specStarted(spec) {
        let currentGroup = this.getCurrentGroup();
        if (currentGroup === null)
            throw new Error("No active suite");
        currentGroup = currentGroup.startGroup("Test wrapper");
        this.groupStack.push(currentGroup);
        const name = spec.description;
        const allureTest = currentGroup.startTest(name);
        if (this.runningTest != null)
            throw new Error("Test is starting before other ended!");
        this.runningTest = allureTest;
        allureTest.fullName = spec.fullName;
        allureTest.historyId = spec.fullName;
        allureTest.stage = allure_js_commons_1.Stage.RUNNING;
        if (this.groupStack.length > 1) {
            allureTest.addLabel(allure_js_commons_1.LabelName.PARENT_SUITE, this.groupStack[0].name);
        }
        if (this.groupStack.length > 2) {
            allureTest.addLabel(allure_js_commons_1.LabelName.SUITE, this.groupStack[1].name);
        }
        if (this.groupStack.length > 3) {
            allureTest.addLabel(allure_js_commons_1.LabelName.SUB_SUITE, this.groupStack[2].name);
        }
        for (const labels of this.labelStack) {
            for (const label of labels) {
                allureTest.addLabel(label.name, label.value);
            }
        }
    }
    specDone(spec) {
        const currentTest = this.runningTest;
        if (currentTest === null)
            throw new Error("specDone while no test is running");
        if (this.stepStack.length > 0) {
            console.error("Allure reporter issue: step stack is not empty on specDone");
            for (const step of this.stepStack.reverse()) {
                step.status = allure_js_commons_1.Status.BROKEN;
                step.stage = allure_js_commons_1.Stage.INTERRUPTED;
                step.detailsMessage = "Timeout";
                step.endStep();
            }
            this.stepStack = [];
        }
        if (spec.status === SpecStatus.PENDING || spec.status === SpecStatus.DISABLED
            || spec.status === SpecStatus.EXCLUDED) {
            currentTest.status = allure_js_commons_1.Status.SKIPPED;
            currentTest.stage = allure_js_commons_1.Stage.PENDING;
            currentTest.detailsMessage = spec.pendingReason || "Suite disabled";
        }
        currentTest.stage = allure_js_commons_1.Stage.FINISHED;
        if (spec.status === SpecStatus.PASSED) {
            currentTest.status = allure_js_commons_1.Status.PASSED;
        }
        if (spec.status === SpecStatus.BROKEN) {
            currentTest.status = allure_js_commons_1.Status.BROKEN;
        }
        if (spec.status === SpecStatus.FAILED) {
            currentTest.status = allure_js_commons_1.Status.FAILED;
        }
        const exceptionInfo = this.findMessageAboutThrow(spec.failedExpectations)
            || this.findAnyError(spec.failedExpectations);
        if (exceptionInfo !== null) {
            currentTest.detailsMessage = exceptionInfo.message;
            currentTest.detailsTrace = exceptionInfo.stack;
        }
        currentTest.endTest();
        this.runningTest = null;
        this.currentGroup.endGroup();
        this.groupStack.pop();
    }
    suiteDone(suite) {
        if (this.runningTest !== null) {
            console.error("Allure reporter issue: running test on suiteDone");
        }
        const currentGroup = this.getCurrentGroup();
        if (currentGroup === null)
            throw new Error("No active suite");
        currentGroup.endGroup();
        this.groupStack.pop();
        this.labelStack.pop();
    }
    jasmineDone(runDetails) { }
    findMessageAboutThrow(expectations) {
        for (const e of expectations || []) {
            if (e.matcherName === "")
                return e;
        }
        return null;
    }
    findAnyError(expectations) {
        expectations = expectations || [];
        if (expectations.length > 0)
            return expectations[0];
        return null;
    }
    addLabel(name, value) {
        if (this.labelStack.length) {
            this.labelStack[this.labelStack.length - 1].push({ name, value });
        }
    }
    pushStep(step) {
        this.stepStack.push(step);
    }
    popStep() {
        this.stepStack.pop();
    }
    get currentStep() {
        if (this.stepStack.length > 0)
            return this.stepStack[this.stepStack.length - 1];
        return null;
    }
    installHooks() {
        const reporter = this;
        const jasmineBeforeAll = eval("global.beforeAll");
        const jasmineAfterAll = eval("global.afterAll");
        const jasmineBeforeEach = eval("global.beforeEach");
        const jasmineAfterEach = eval("global.afterEach");
        function makeWrapperAll(wrapped, fun) {
            return function (action, timeout) {
                wrapped(function (done) {
                    reporter.runningExecutable = fun();
                    let ret;
                    if (action.length > 0) {
                        ret = reporter.runningExecutable.wrap(() => new Promise((resolve, reject) => {
                            const t = resolve;
                            t.fail = reject;
                            action(t);
                        }))();
                    }
                    else {
                        ret = reporter.runningExecutable.wrap(action)();
                    }
                    if (allure_js_commons_1.isPromise(ret)) {
                        ret.then(() => {
                            reporter.runningExecutable = null;
                            done();
                        }).catch(e => {
                            reporter.runningExecutable = null;
                            done.fail(e);
                        });
                    }
                    else {
                        reporter.runningExecutable = null;
                        done();
                    }
                }, timeout);
            };
        }
        const wrapperBeforeAll = makeWrapperAll(jasmineBeforeAll, () => reporter.currentGroup.addBefore());
        const wrapperAfterAll = makeWrapperAll(jasmineAfterAll, () => reporter.currentGroup.addAfter());
        const wrapperBeforeEach = makeWrapperAll(jasmineBeforeEach, () => reporter.currentGroup.addBefore());
        const wrapperAfterEach = makeWrapperAll(jasmineAfterEach, () => reporter.currentGroup.addAfter());
        eval("global.beforeAll = wrapperBeforeAll;");
        eval("global.afterAll = wrapperAfterAll;");
        eval("global.beforeEach = wrapperBeforeEach;");
        eval("global.afterEach = wrapperAfterEach;");
    }
}
exports.JasmineAllureReporter = JasmineAllureReporter;
class JasmineAllureInterface extends allure_js_commons_1.Allure {
    constructor(reporter, runtime) {
        super(runtime);
        this.reporter = reporter;
    }
    label(name, value) {
        try {
            this.reporter.currentTest.addLabel(name, value);
        }
        catch (_a) {
            this.reporter.addLabel(name, value);
        }
    }
    get currentExecutable() {
        return this.reporter.currentStep || this.reporter.currentExecutable || this.reporter.currentTest;
    }
    get currentTest() {
        return this.reporter.currentTest;
    }
    startStep(name) {
        const allureStep = this.currentExecutable.startStep(name);
        this.reporter.pushStep(allureStep);
        return new WrappedStep(this.reporter, allureStep);
    }
    step(name, body) {
        const wrappedStep = this.startStep(name);
        let result;
        try {
            result = wrappedStep.run(body);
        }
        catch (err) {
            wrappedStep.endStep();
            throw err;
        }
        if (allure_js_commons_1.isPromise(result)) {
            const promise = result;
            return promise.then(a => {
                wrappedStep.endStep();
                return a;
            }).catch(e => {
                wrappedStep.endStep();
                throw e;
            });
        }
        else {
            wrappedStep.endStep();
            return result;
        }
    }
    logStep(name, status) {
        this.step(name, () => { });
    }
    attachment(name, content, type) {
        const file = this.reporter.writeAttachment(content, type);
        this.currentExecutable.addAttachment(name, type, file);
    }
}
exports.JasmineAllureInterface = JasmineAllureInterface;
class WrappedStep {
    constructor(reporter, step) {
        this.reporter = reporter;
        this.step = step;
    }
    startStep(name) {
        const step = this.step.startStep(name);
        this.reporter.pushStep(step);
        return new WrappedStep(this.reporter, step);
    }
    endStep() {
        this.reporter.popStep();
        this.step.endStep();
    }
    run(body) {
        return this.step.wrap(body)();
    }
}
//# sourceMappingURL=JasmineAllureReporter.js.map